commonfields:
  id: Create-Mock-Feed
  version: -1
name: Create-Mock-Feed
display: Create-Mock-Feed
description: "Mock Feed"
system: false
category: Data Enrichment & Threat Intelligence
image: data:image/png;base64,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
configuration:
- display: Indicator Type
  name: indicator_type
  defaultvalue: ""
  type: 15
  required: true
  options:
  - Domain
  - File
  - IP
- display: Amount of indicators
  name: amount_inidcators
  defaultvalue: "100000"
  type: 0
  required: false
- display: Size of batches
  name: batch_size
  defaultvalue: "30000"
  type: 0
  required: false
  hidden: true
- display: Feed Fetch Interval
  name: feedFetchInterval
  required: false
  type: 19
- display: Fetch indicators
  name: feed
  defaultvalue: "true"
  type: 8
  required: false
- display: Incidents name
  name: incidents_name
  defaultvalue: ""
  type: 0
  required: false
  hidden: true
- display: Fieldnames (CSV)
  name: fieldnames
  defaultvalue: indicator,description,date
  type: 0
  required: false
  additionalinfo: Make sure to have the key "indicator" in the appropriate CSV column
    where the value of the indicator is expected to be
- display: ''
  name: feedExpirationInterval
  required: false
  type: 1
- display: Indicator Reputation
  name: feedReputation
  type: 18
  required: false
  options:
  - None
  - Good
  - Suspicious
  - Bad
  additionalinfo: Indicators from this integration instance will be marked with this
    reputation
- display: Source Reliability
  name: feedReliability
  type: 15
  required: true
  options:
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  additionalinfo: Reliability of the source providing the intelligence data
- display: ''
  name: feedExpirationPolicy
  type: 17
  required: false
  options:
  - never
  - interval
  - indicatorType
  - suddenDeath
- display: Bypass exclusion list
  name: feedBypassExclusionList
  type: 8
  required: false
  additionalinfo: When selected, the exclusion list is ignored for indicators from
    this feed. This means that if an indicator from this feed is on the exclusion
    list, the indicator might still be added to the system.
- additionalinfo: Supports CSV values.
  display: Tags
  name: feedTags
  required: false
  type: 0
- additionalinfo: The Traffic Light Protocol (TLP) designation to apply to indicators
    fetched from the feed
  display: Traffic Light Protocol Color
  name: tlp_color
  options:
  - RED
  - AMBER
  - GREEN
  - WHITE
  required: false
  type: 15
script:
  script: |-
    import urllib3
    import csv
    from time import perf_counter as timer
    import itertools
    from pathlib import Path

    # disable insecure warnings
    urllib3.disable_warnings()

    REGEX = OrderedDict()
    REGEX['IP'] = ipv4Regex
    REGEX['Domain'] = r'([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}'
    REGEX['Email'] = emailRegex
    REGEX['URL'] = urlRegex
    REGEX['File'] = r'\b[a-fA-F\d]{64}|[a-fA-F\d]{40}|[a-fA-F\d]{32}|[a-fA-F\d]{128}\b'

    TYPE_TO_FILENAME = OrderedDict()
    TYPE_TO_FILENAME['IP'] = 'ips.csv'
    TYPE_TO_FILENAME['Domain'] = 'domains.csv'
    TYPE_TO_FILENAME['File'] = 'hashes.csv'

    def create_run_info(batches=[], total_indicators=0, total_feed_time=0):
        return {
            "batches": batches,
            "total_indicators": total_indicators,
            "total_feed_time": total_feed_time
    }

    def create_batch(size=None, time=None):
        return {
            "size": size,
            "time": time
        }

    def get_indicator_type(item):
        for indicator_type, pattern in REGEX.items():
            if re.match(pattern, str(item)):
                return indicator_type
        return ''


    def build_iterator(f, fieldnames, dialect):
        csvreader = csv.DictReader(
            f,
            fieldnames=fieldnames,
            **dialect
        )
        return csvreader

    def good_batch(iterable, size):
        it = iter(iterable)
        while True:
            chunk = tuple(itertools.islice(it, size))
            if not chunk:
                break
            yield chunk


    def generate_dbotscore(indicator, indicator_type):
        the_hash = hash(indicator)
        last_digit = abs(the_hash) % 10
        if last_digit < 5:
            score = 1
        elif last_digit < 8:
            score = 2
        else:
            score = 3
        return {
            "Indicator": indicator,
            "Type": indicator_type,
            "Vendor": "Bar Saar",
            "Score": score
        }


    def main():
        if demisto.command() == 'fetch-indicators':
            indicators = []
            indicator_types = argToList(demisto.params().get('indicator_type'))

            if not indicator_types:
                indicator_types = ['IP']
            demisto.info(f'starting feed with types {indicator_types}')
            demisto.info(f'starting feed with types {len(indicator_types)} size')
            for indicator_type in indicator_types:
                csv_file = TYPE_TO_FILENAME[indicator_type]
                indicators_csv_file = open(Path('/perf/' + csv_file), newline='')
                fieldnames = argToList(demisto.params().get('fieldnames'))
                dialect = {
                    'delimiter': demisto.params().get('delimiter', ','),
                    'doublequote': demisto.params().get('doublequote', True),
                    'escapechar': demisto.params().get('escapechar', None),
                    'quotechar': demisto.params().get('quotechar', '"'),
                    'skipinitialspace': demisto.params().get('skipinitialspace', False)
                }
                iterator = build_iterator(indicators_csv_file, fieldnames, dialect)
                for item in iterator:
                  if 'indicator' in item:
                    raw_json = dict(item)
                    raw_json['value'] = indicator = item.get('indicator')
                    raw_json['type'] = indicator_type
                    indicators.append({
                        "value": indicator,
                        "type": indicator_type,
                        "rawJSON": raw_json,
                    })
                  else:
                    raise Exception("abc")

                batch_size = int(demisto.params().get('batch_size'))
                batches = []
                feed_start = timer()
                indicators = indicators[:int(demisto.params().get('amount_inidcators'))]
                demisto.info(f'starting feed of {len(indicators)} size')
                for b in good_batch(indicators, batch_size):
                    batch_start = timer()
                    demisto.createIndicators(b)
                    batch_end = timer()
                    batch_time = batch_end - batch_start
                    batch_info = create_batch(len(b), batch_time)
                    batches.append(batch_info)
                feed_end = timer()
                demisto.info('finished feed')
                feed_total_time = feed_end - feed_start
                run_info = create_run_info(batches, len(indicators), feed_total_time)
                incidents = [{"name": demisto.params().get('incidents_name'), "type": "Access", "details": json.dumps(run_info)}]
                demisto.createIncidents(incidents)
                demisto.info('feed finished create result incident')
        elif demisto.command() == 'random-score-indicators':
                indicators = argToList(demisto.args().get('indicators')) or []
                dbot_scores = [generate_dbotscore(i, get_indicator_type(i)) for i in indicators]
                ec = {}
                ec['DBotScore'] = dbot_scores
                md = tableToMarkdown("Indicator DBot Score", ec["DBotScore"])
                demisto.results({
                    "Type": 1,
                    "ContentsFormat": "json",
                    "Contents": ec,
                    "HumanReadable": md,
                    "EntryContext": ec
                })

    # python2 uses __builtin__ python3 uses builtin s
    if __name__ == "__builtin__" or __name__ == "builtins":
        main()
  type: python
  commands: []
  dockerimage: devdemisto/feed-performance-test:1.0.7039
  feed: true
  runonce: false
  subtype: python3
fromversion: 5.5.0
tests:
- No tests (auto formatted)
